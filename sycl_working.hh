
// A dynamic programming evaluator generated by GAP-C.
//
//   GAP-C version:
//     2024.05.14
//
//   GAP-C call:
//     ./gapc --cyk -i ins_needlemanwunsch_similarity alignments_singletrack.gap -o new.cc
//
//


#ifndef sycl_working_hh
#define sycl_working_hh

#define GAPC_CALL_STRING "./gapc --cyk -i ins_needlemanwunsch_similarity alignments_singletrack.gap -o new.cc"
#define GAPC_VERSION_STRING "2024.05.14"

#include "rtlib/adp.hh"
#include <sycl/sycl.hpp>

typedef Basic_Subsequence<char, unsigned> TUSubsequence;

struct typ_ali {
  Rope first;
  Rope second;
  bool empty_;
  typ_ali() : empty_(false) {}
};

inline std::ostream &operator<<(std::ostream &o, const typ_ali &tuple) {
  o << '('   << tuple.first   << ", " << tuple.second
    << ')' ;
  return o;
}

inline void empty(typ_ali &e) {e.empty_ = true; }
inline bool isEmpty(const typ_ali &e) { return e.empty_; }
#include "rtlib/subopt.hh"
#include "ext_alignment.hh"

#include "rtlib/generic_opts.hh"
#include "rtlib/pareto_dom_sort.hh"
#include "rtlib/pareto_yukish_ref.hh"

class sycl_working {
 public:
  
  sycl::device d;
  sycl::queue q{};

  Basic_Sequence<char> *seq = sycl::malloc_shared<Basic_Sequence<char>>(1, q);

  Basic_Sequence<char> t_0_seq;

  unsigned int t_0_left_most;
  unsigned int t_0_right_most;
  unsigned int tile_size, max_tiles;
  int max_tiles_n;
  int num_tiles_per_axis;

  int int_zero;


  class A_table_t {
   private:
    unsigned int t_0_left_most;
    unsigned int t_0_right_most;
    std::vector<int> array;
    unsigned int t_0_n;
    int zero;
    unsigned int size() {
      return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
    }

   public:
    A_table_t() {
      empty(zero);
    }

    void init(unsigned int t_0_n_, const std::string &tname) {
      t_0_n = t_0_n_;
      t_0_left_most = 0;
      t_0_right_most = t_0_n;
      unsigned int newsize = size();
      array.resize(newsize);
    }

    int &  get(unsigned int t_0_i, unsigned int t_0_j) {
      assert((t_0_i <= t_0_j));
      assert((t_0_j <= t_0_n));
      if (((t_0_j - t_0_i) < 1)) {
        return zero;
      }
      assert(((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
      return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
    }

    void set(unsigned int t_0_i, unsigned int t_0_j, int e) {
      assert((t_0_i <= t_0_j));
      assert((t_0_j <= t_0_n));
      if (((t_0_j - t_0_i) < 1)) {
        assert(0);
      }
      assert(((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
      array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
    }
  };
 
  A_table_t *A_table = sycl::malloc_shared<A_table_t>(1, q);
  A_table_t B_table;

  void init(const gapc::Opts &opts) {
    const std::vector<std::pair<const char *, unsigned>> &inp = opts.inputs;

    if (inp.size() != 1)
      throw gapc::OptException("Number of input sequences does not match.");

    d = sycl::device(sycl::cpu_selector_v);

    t_0_seq.copy(inp[0].first, inp[0].second);
    seq = &t_0_seq;

    tile_size = opts.tile_size;
    max_tiles = (seq->size() / tile_size);
    max_tiles_n = (max_tiles * tile_size);
    int num_tiles_per_axis =
        (((tile_size < (seq->size() - 1)))
             ? (((seq->size() - (tile_size - 1)) / tile_size))
             : (0));
    B_table.init(seq->size(), "A_table");
    A_table = &B_table;

    empty(int_zero);

    t_0_left_most = 0;
    t_0_right_most = seq->size();
  }

 private:
  int &  nt_A(unsigned int t_0_i, unsigned int t_0_j);

  void nt_tabulate_A(unsigned int t_0_i, unsigned int t_0_j);

  int Del(int x, char b);

  int Ers(char a, int x, char b);

  int Ins(char a, int x);

  int Sto(char sep);

  int h(int candidates);


 public:
  void cyk();
 private:
 public:
  int &  run() {
    return nt_A(t_0_left_most, t_0_right_most);
  }

  void print_stats(std::ostream &o) {
#ifdef STATS
    o << "\n\nN = " << seq.size() << '\n';
    A_table.print_stats(o, "A_table");
#endif
  }

  template <typename Value> void  print_result(std::ostream &out, Value& res) {
    if (isEmpty(res)) {
      out << "[]\n";
    } else {
      out << res << '\n';
    }
  }

  template <typename Value> void print_backtrack(std::ostream &out, Value& value) {
  }

  void print_subopt(std::ostream &out, int  delta = 0) {
  }

  void print_document_header(std::ostream &out) {
  }

  void print_document_footer(std::ostream &out) {
  }
};

#ifndef NO_GAPC_TYPEDEFS
namespace gapc {
  typedef sycl_working class_name;
  typedef int &  return_type;
}
#endif

#endif
