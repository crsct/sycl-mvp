
// A dynamic programming evaluator generated by GAP-C.
//
//   GAP-C version:
//     2024.05.14
//
//   GAP-C call:
//     ./gapc --cyk --sycl -i ins_needlemanwunsch_similarity alignments_singletrack.gap -o sycl_working.cc
//
//


#define GAPC_MOD_TRANSLATION_UNIT
#define _SYCL
#include "sycl_working.hh"
#include <sycl/sycl.hpp>
#include <CL/sycl.hpp>
#include "rtlib/subopt.hh"
#include "ext_alignment.hh"

#include "sequence.hh"
#include "string.hh"

#include "rtlib/generic_opts.hh"
#include "rtlib/pareto_dom_sort.hh"
#include "rtlib/pareto_yukish_ref.hh"

int &  sycl_working::nt_A(unsigned int t_0_i, unsigned int t_0_j) {
  return A_table->get(t_0_i, t_0_j);
}

void sycl_working::nt_tabulate_A(unsigned int t_0_i, unsigned int t_0_j) {
  Basic_Sequence<char> &t_0_seq = *seq;
  if (((t_0_j - t_0_i) < 1)) {
    return;
  }
  int answers;
  empty(answers);
  empty(answers);
  int ret_0;
  if (((t_0_j - t_0_i) >= 2)) {
    char ret_1 = CHAR(t_0_seq, t_0_i, (t_0_i + 1));
    char a_0 = ret_1;
    if (is_not_empty(a_0)) {
      int ret_2 = nt_A((t_0_i + 1), t_0_j);
      int a_1 = ret_2;
      if (is_not_empty(a_1)) {
        ret_0 = Ins(a_0, a_1);
      } else {
        empty(ret_0);
      }
      erase(a_1);
    } else {
      empty(ret_0);
    }
    erase(a_0);
  } else {
    empty(ret_0);
  }
  if (is_not_empty(ret_0)) {
    push_back_max(answers, ret_0);
  }
  int ret_3;
  if (((t_0_j - t_0_i) >= 2)) {
    char ret_5 = CHAR(t_0_seq, (t_0_j - 1), t_0_j);
    char a_3 = ret_5;
    if (is_not_empty(a_3)) {
      int ret_4 = nt_A(t_0_i, (t_0_j - 1));
      int a_2 = ret_4;
      if (is_not_empty(a_2)) {
        ret_3 = Del(a_2, a_3);
      } else {
        empty(ret_3);
      }
      erase(a_2);
    } else {
      empty(ret_3);
    }
    erase(a_3);
  } else {
    empty(ret_3);
  }
  if (is_not_empty(ret_3)) {
    push_back_max(answers, ret_3);
  }
  int ret_6;
  if (((t_0_j - t_0_i) >= 3)) {
    char ret_9 = CHAR(t_0_seq, (t_0_j - 1), t_0_j);
    char a_6 = ret_9;
    if (is_not_empty(a_6)) {
      char ret_7 = CHAR(t_0_seq, t_0_i, (t_0_i + 1));
      char a_4 = ret_7;
      if (is_not_empty(a_4)) {
        int ret_8 = nt_A((t_0_i + 1), (t_0_j - 1));
        int a_5 = ret_8;
        if (is_not_empty(a_5)) {
          ret_6 = Ers(a_4, a_5, a_6);
        } else {
          empty(ret_6);
        }
        erase(a_5);
      } else {
        empty(ret_6);
      }
      erase(a_4);
    } else {
      empty(ret_6);
    }
    erase(a_6);
  } else {
    empty(ret_6);
  }
  if (is_not_empty(ret_6)) {
    push_back_max(answers, ret_6);
  }
  int ret_10;
  if ((((t_0_j - t_0_i) >= 1) && ((t_0_j - t_0_i) <= 1))) {
    char ret_11;
    if (((((t_0_i + 1) - t_0_i) >= 1) && (((t_0_i + 1) - t_0_i) <= 1))) {
      ret_11 = CHAR(t_0_seq, t_0_i, (t_0_i + 1), '@');
    } else {
      empty(ret_11);
    }
    char a_7 = ret_11;
    if (is_not_empty(a_7)) {
      ret_10 = Sto(a_7);
    } else {
      empty(ret_10);
    }
    erase(a_7);
  } else {
    empty(ret_10);
  }
  if (is_not_empty(ret_10)) {
    push_back_max(answers, ret_10);
  }
  int eval = h(answers);
  erase(answers);
  A_table->set(t_0_i, t_0_j, eval);
  return;
}


int sycl_working::Del(int x, char b) {
#line 35 "alignments_singletrack.gap"
  return (x - 2);
#line 143 "sycl_working.cc"
}

int sycl_working::Ers(char a, int x, char b) {
#line 38 "alignments_singletrack.gap"
  if ((a == b)) {
    return (x + 1);
  } else {
    return (x - 1);
  }
#line 153 "sycl_working.cc"
}

int sycl_working::Ins(char a, int x) {
#line 32 "alignments_singletrack.gap"
  return (x - 2);
#line 159 "sycl_working.cc"
}

int sycl_working::Sto(char sep) {
#line 45 "alignments_singletrack.gap"
  return 0;
#line 165 "sycl_working.cc"
}

int sycl_working::h(int candidates) {
  return candidates;
  return maximum(candidates);
}

char local(Basic_Sequence<char> &seq, unsigned int i) {
  return seq[i];
}

void clean() {
  // sycl::free(A_table, q);V
  // sycl::free(seq, q);
}


void sycl_working::cyk() {
// #define _OPENMP
#ifdef _OPENMP
#pragma omp parallel
  {
#pragma omp for
    // OPENMP < 3 requires signed int here ...
    for (int z = 0; (z < max_tiles_n); z += tile_size) {
      for (unsigned int t_0_j = z; (t_0_j < (z + tile_size)); ++t_0_j) {
        for (int t_0_i = (t_0_j + 1); (t_0_i > z); t_0_i += -1) {
          nt_tabulate_A((t_0_i - 1), t_0_j);
        }
      }
    }
    for (int z = tile_size; (z < max_tiles_n); z += tile_size) {
#pragma omp for
      for (int y = z; (y < max_tiles_n); y += tile_size) {
        unsigned int x = ((y - z) + tile_size);
        for (unsigned int t_0_j = y; (t_0_j < (y + tile_size)); ++t_0_j) {
          for (int t_0_i = x; (t_0_i > (x - tile_size)); t_0_i += -1) {
            nt_tabulate_A((t_0_i - 1), t_0_j);
          }
        }
      }
    }
    // end parallel
  }

  for (unsigned int t_0_j = max_tiles_n; (t_0_j < t_0_seq.size()); ++t_0_j) {
    for (unsigned int t_0_i = (t_0_j + 1); (t_0_i > 1); t_0_i += -1) {
      nt_tabulate_A((t_0_i - 1), t_0_j);
    }
    unsigned int t_0_i = 1;
    nt_tabulate_A((t_0_i - 1), t_0_j);
  }
  unsigned int t_0_j = t_0_seq.size();
  for (unsigned int t_0_i = (t_0_j + 1); (t_0_i > 1); t_0_i += -1) {
    nt_tabulate_A((t_0_i - 1), t_0_j);
  }
  unsigned int t_0_i = 1;
  nt_tabulate_A((t_0_i - 1), t_0_j);
#elif defined(_SYCL)
// #if defined(_SYCL)

  q.submit([&](sycl::handler& h) {
    h.parallel_for(sycl::range<1> (max_tiles), [=](sycl::id<1> z) {
      for (unsigned int t_0_j = (z * tile_size); (t_0_j < ((z * tile_size) + tile_size)); ++t_0_j) {
        for (unsigned int t_0_i = (t_0_j + 1); (t_0_i > (z * tile_size)); t_0_i += -1) {
          nt_tabulate_A((t_0_i - 1), t_0_j);
        }
      }
    });
  });
  q.wait();
  for (int i = 0; (i < max_tiles); ++i) {
    q.submit([&](sycl::handler& h) {
      h.parallel_for(sycl::range<1> (max_tiles), [=](sycl::id<1> y) {
        unsigned int x = ((y - (i * tile_size) ) + tile_size);
        for (unsigned int t_0_j = y; (t_0_j < (y + tile_size)); ++t_0_j) {
          for (unsigned int t_0_i = x; (t_0_i > (x - tile_size)); t_0_i += -1) {
            nt_tabulate_A((t_0_i - 1), t_0_j);
          }
        }
      });
    });
    q.wait();
  }

  q.wait();
  
  for (unsigned int t_0_j = max_tiles * tile_size; (t_0_j < seq->size()); ++t_0_j) {
    for (unsigned int t_0_i = (t_0_j + 1); (t_0_i > 1); t_0_i += -1) {
      nt_tabulate_A((t_0_i - 1), t_0_j);
    }
    unsigned int t_0_i = 1;
    nt_tabulate_A((t_0_i - 1), t_0_j);
  }
  unsigned int t_0_j = seq->size();
  for (unsigned int t_0_i = (t_0_j + 1); (t_0_i > 1); t_0_i += -1) {
    nt_tabulate_A((t_0_i - 1), t_0_j);
  }
  unsigned int t_0_i = 1;
  nt_tabulate_A((t_0_i - 1), t_0_j);
  
#else
  for (unsigned int t_0_j = 0; (t_0_j < t_0_seq.size()); ++t_0_j) {
    for (unsigned int t_0_i = (t_0_j + 1); (t_0_i > 1); t_0_i += -1) {
      nt_tabulate_A((t_0_i - 1), t_0_j);
    }
    unsigned int t_0_i = 1;
    nt_tabulate_A((t_0_i - 1), t_0_j);
  }
  unsigned int t_0_j = t_0_seq.size();
  for (unsigned int t_0_i = (t_0_j + 1); (t_0_i > 1); t_0_i += -1) {
    nt_tabulate_A((t_0_i - 1), t_0_j);
  }
  unsigned int t_0_i = 1;
  nt_tabulate_A((t_0_i - 1), t_0_j);
#endif
}
#ident "$Id: Compiled with gapc 2024.05.14 $"
